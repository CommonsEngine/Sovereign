/// GENERATED FILE — DO NOT EDIT
/// Combined on 2025-11-15T04:05:16.152Z

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// [1] User model / User management
enum UserStatus {
  invited
  active
  suspended
}

enum UserType {
  human
  bot
}

model User {
  id         String       @id @default(cuid()) @map("id")
  type       UserType     @default(human) @map("type")
  name       String       @unique @map("name")
  firstName  String?      @map("first_name")
  lastName   String?      @map("last_name")
  pictureUrl String?      @map("picture_url")
  profile    UserProfile? @relation(name: "UserToUserProfile")

  primaryEmailId  String?     @unique @map("primary_email_id")
  primaryEmail    UserEmail?  @relation("PrimaryEmail", fields: [primaryEmailId], references: [id])
  emails          UserEmail[] @relation("UserEmails")
  emailVerifiedAt DateTime?   @map("email_verified_at")

  passwordHash        String?              @map("password_hash") // allow empty until user sets it
  sessions            Session[]
  verificationTokens  VerificationToken[]  @relation("UserToVerificationTokens")
  passwordResetTokens PasswordResetToken[] @relation("UserToPasswordResetTokens")

  // Add opposite relation for UserRoleAssignment
  roleAssignments UserRoleAssignment[]

  projectContributions ProjectContributor[]

  isTestUser Boolean @default(false) @map("is_test_user")

  status    UserStatus @default(invited) @map("status")
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  @@index([createdAt])
  @@index([emailVerifiedAt])
  @@map("users")
}

// [1.1] User profile (1:1 with User)
model UserProfile {
  userId   String  @id @map("user_id")
  locale   String?
  timezone String?
  meta     Json?

  // Relations
  user User @relation(name: "UserToUserProfile", fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

// [1.2] User emails
model UserEmail {
  id         String    @id @default(uuid())
  userId     String
  email      String    @unique
  isVerified Boolean   @default(false) @map("is_verified")
  isPrimary  Boolean   @default(false) @map("is_primary")
  createdAt  DateTime  @default(now()) @map("created_at")
  verifiedAt DateTime? @map("verified_at")

  user User @relation("UserEmails", fields: [userId], references: [id])

  /// Backref for the optional primaryEmail relation on User (1:1)
  primaryOf User? @relation("PrimaryEmail")

  @@unique([userId, id]) // supports composite FK from User(id, primaryEmailId) -> (userId, id)
  @@index([userId, isPrimary])
  @@map("user_emails")
}

// [1.3] User roles and capabilities
enum UserRoleScope {
  platform
  tenant
  project
  service
}

model UserRole {
  id          Int           @id @map("id") // SMALLINT → Int
  key         String        @unique
  label       String
  level       Int
  scope       UserRoleScope
  description String
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  roleCapabilities UserRoleCapability[]
  roleAssignments  UserRoleAssignment[] // opposite relation for UserRoleAssignment

  @@map("user_roles")
}

model UserCapability {
  key         String   @id
  description String
  source      String?  @map("source")
  namespace   String?  @map("namespace")
  scope       String?  @map("scope")
  category    String?  @map("category")
  tags        Json?    @map("tags")
  metadata    Json?    @map("metadata")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @updatedAt @map("updated_at")

  // Relations
  roleCapabilities UserRoleCapability[]

  @@map("user_capabilities")
}

enum CapabilityValue {
  allow
  deny
  consent
  compliance
  scoped
  anonymized
}

model UserRoleCapability {
  roleId        Int
  capabilityKey String
  value         CapabilityValue @default(deny)

  // Relations
  role       UserRole       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  capability UserCapability @relation(fields: [capabilityKey], references: [key], onDelete: Cascade)

  @@id([roleId, capabilityKey])
  @@map("user_role_capabilities")
}

model UserRoleAssignment {
  id     String @id @default(cuid())
  userId String
  roleId Int

  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role UserRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@unique([userId, roleId])
  @@index([roleId])
  @@map("user_role_assignments")
}

// [1.4] Session model
model Session {
  id                    String  @id @default(cuid()) @map("id")
  userId                String  @map("user_id")
  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  token                 String  @unique @map("token")
  ipHash                String? @map("ip_hash")
  userAgent             String? @map("user_agent")
  roles                 Json?   @map("roles")
  capabilities          Json?   @map("capabilities")
  userSnapshot          Json?   @map("user_snapshot")
  capabilitiesSignature String? @map("capabilities_signature")

  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

// [1.5] Tokens for invites, email verification 
model VerificationToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToVerificationTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  purpose   String   @map("purpose") // 'email-verify'
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("verification_tokens")
}

// [1.6] Tokens for password resets
model PasswordResetToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToPasswordResetTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

// [2] App settings / Version registry
model AppSetting {
  id        String   @id @default(cuid()) @map("id")
  scope     String   @map("scope") // 'global', 'org:{orgId}', 'user:{userId}', 'project:{projectId}'
  key       String   @unique @map("key")
  value     Json     @map("value")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([scope, key])
  @@index([scope])
  @@map("app_settings")
}

model VersionRegistry {
  id        String   @id // appsettings, locales, ...
  v         Int      @default(1)
  updatedAt DateTime @updatedAt

  @@map("version_registry")
}

// [3] Projects and related models

enum ProjectScope {
  private
  org
  public
}

enum ProjectStatus {
  draft
  published
}

enum ContributorRole {
  owner
  editor
  viewer
}

enum ContributorStatus {
  pending
  active
  revoked
}

model Project {
  id   String  @id @default(cuid()) @map("id")
  name String  @default("Untitled") @map("name")
  slug String? @unique @map("slug")
  desc String? @map("desc")

  type String @map("type") // plugin namespace

  // lifecycle / meta
  scope  ProjectScope?  @map("scope")
  status ProjectStatus? @default(draft) @map("status")

  // optional multi-tenant support
  tenantId String? @default("tenant-0") @map("tenant_id")

  contributors ProjectContributor[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  GitConfig GitConfig?
  blog      Blog?

  @@map("projects")
}

model ProjectContributor {
  id           String            @id @default(cuid()) @map("id")
  projectId    String            @map("project_id")
  userId       String?           @map("user_id")
  invitedEmail String?           @map("invited_email")
  role         ContributorRole   @map("role")
  status       ContributorStatus @default(pending) @map("status")
  invitedAt    DateTime          @default(now()) @map("invited_at")
  acceptedAt   DateTime?         @map("accepted_at")
  note         String?           @map("note")

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User?   @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([projectId, userId])
  @@unique([projectId, invitedEmail])
  @@index([userId])
  @@index([invitedEmail])
  @@map("project_contributors")
}

// [3.1.1] Git configuration for blogs
enum GitProvider {
  github
  gitlab
  bitbucket
  other
}

enum AuthType {
  ssh
  https
  token
  userpass
}

model GitConfig {
  id        String   @id @default(cuid()) @map("id")
  projectId String?  @unique @map("project_id")
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  provider   GitProvider @map("provider")
  repoUrl    String      @map("repo_url")
  branch     String      @default("main") @map("branch")
  contentDir String?     @map("content_dir")
  authType   AuthType?   @default(ssh) @map("auth_type")
  authSecret String?     @map("auth_secret")
  meta       Json?       @map("meta") // e.g., { "lastSyncedAt": "2023-10-01T12:00:00Z" }

  userName  String? @map("user_name")
  userEmail String? @map("user_email")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  blogs     Blog[]

  @@map("git_configs")
}

/// --- Plugin: blog ---
/// Source: plugins/blog/prisma/extension.prisma

// [3.1] Blog model (for projects of type 'blog')
enum BlogProvider {
  astro
}

model Blog {
  id        String   @id @default(cuid()) @map("id")
  projectId String   @unique @map("project_id")
  project   Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  title     String       @map("title")
  subtitle  String?      @map("subtitle")
  type      String       @default("blog:git") @map("type") // e.g., 'blog:git'
  provider  BlogProvider @default(astro) @map("provider") // e.g., 'astro', 'jekyll'
  gitConfig GitConfig?   @relation(fields: [gitConfigId], references: [id])
  domain    String?      @unique @map("domain") // custom domain
  meta      Json?        @map("meta") // e.g., { "theme": "minimal", "postsPerPage": 10 }

  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  gitConfigId String?

  @@map("blogs")
}

/// --- Plugin: tasks ---
/// Source: plugins/tasks/prisma/extension.prisma

// ============================================================
// Sovereign Tasks – Prisma Extension Schema (Phase 2 Draft)
// This file defines server-side persistence for the Tasks plugin.
// ============================================================

// ============================================================
// TASK LISTS
// ============================================================

model TaskList {
  id        Int      @id @default(autoincrement()) @map("id")
  userId    String   @map("user_id")
  name      String   @map("name")
  slug      String   @map("slug")
  position  Int      @default(0) @map("position") // ordering among lists
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tasks        Task[]
  shareInvites TaskListShareInvite[]

  @@unique([userId, slug])
  @@index([userId])
  @@index([position])
  @@map("task_lists")
}

// ============================================================
// TASKS
// ============================================================

model Task {
  id          Int       @id @default(autoincrement()) @map("id")
  userId      String    @map("user_id")
  listId      Int       @map("list_id")
  title       String    @map("title")
  description String?   @map("description")
  dueDate     DateTime? @map("due_date")

  /// Structured recurrence configuration (mirrors client-side `task.recurring`):
  /// {
  ///   "kind": "preset" | "custom",
  ///   "preset"?: "daily" | "weekly" | "monthly" | "yearly" | "weekday",
  ///   "custom"?: {
  ///     "interval": number,
  ///     "unit": "day" | "week" | "month" | "year",
  ///     "ends": {
  ///       "type": "never" | "onDate" | "afterCount",
  ///       "date"?: string,   // ISO date for "onDate"
  ///       "count"?: number   // remaining occurrences for "afterCount"
  ///     }
  ///   }
  /// }
  recurringConfig Json? @map("recurring_config")

  completed Boolean  @default(false) @map("completed")
  starred   Boolean  @default(false) @map("starred")
  position  Int      @default(0) @map("position") // ordering inside list
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  list          TaskList       @relation(fields: [listId], references: [id])
  taskReminders TaskReminder[]

  @@index([userId])
  @@index([listId])
  @@index([position])
  @@map("tasks")
}

// ============================================================
// OPTIONAL: REMINDERS / AUTOMATION HOOKS (Phase 2.5+)
// ============================================================

model TaskReminder {
  id           Int       @id @default(autoincrement()) @map("id")
  taskId       Int       @map("task_id")
  userId       String    @map("user_id")
  reminderAt   DateTime  @map("reminder_at")
  snoozeUntil  DateTime? @map("snooze_until")
  sourcePlugin String?   @map("source_plugin")

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([taskId])
  @@map("task_reminders")
}

// ============================================================
// TASK LIST SHARING – INVITES (Phase 2)
// ============================================================

model TaskListShareInvite {
  id        Int      @id @default(autoincrement()) @map("id")
  listId    Int      @map("list_id")
  inviterId String   @map("inviter_id") // user who initiated the share
  email     String   @map("email") // email address of the invitee
  token     String   @unique @map("token")
  role      String   @default("editor") @map("role") // e.g. "viewer" | "editor"
  status    String   @default("pending") @map("status") // "pending" | "accepted" | "revoked"
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  list TaskList @relation(fields: [listId], references: [id], onDelete: Cascade)

  @@index([listId])
  @@index([email])
  @@index([inviterId])
  @@map("task_list_share_invites")
}
