datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// [1] User model / User management
enum UserStatus {
  invited
  active
  suspended
}

enum UserType {
  human
  bot
}

model User {
  id         String       @id @default(cuid()) @map("id")
  type       UserType     @default(human) @map("type")
  name       String       @unique @map("name")
  firstName  String?      @map("first_name")
  lastName   String?      @map("last_name")
  pictureUrl String?      @map("picture_url")
  profile    UserProfile? @relation(name: "UserToUserProfile")

  primaryEmailId  String?     @unique @map("primary_email_id")
  primaryEmail    UserEmail?  @relation("PrimaryEmail", fields: [primaryEmailId], references: [id])
  emails          UserEmail[] @relation("UserEmails")
  emailVerifiedAt DateTime?   @map("email_verified_at")

  passwordHash        String?              @map("password_hash") // allow empty until user sets it
  sessions            Session[]
  verificationTokens  VerificationToken[]  @relation("UserToVerificationTokens")
  passwordResetTokens PasswordResetToken[] @relation("UserToPasswordResetTokens")

  // Add opposite relation for UserRoleAssignment
  roleAssignments UserRoleAssignment[]

  status    UserStatus @default(invited) @map("status")
  createdAt DateTime   @default(now()) @map("created_at")
  updatedAt DateTime   @updatedAt @map("updated_at")

  @@index([createdAt])
  @@index([emailVerifiedAt])
  @@map("users")
}

// [1.1] User profile (1:1 with User)
model UserProfile {
  userId   String  @id @map("user_id")
  locale   String?
  timezone String?
  meta     Json // Remove @default("{}")

  // Relations
  user User @relation(name: "UserToUserProfile", fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

// [1.2] User emails
model UserEmail {
  id         String    @id @default(uuid())
  userId     String
  email      String    @unique
  isVerified Boolean   @default(false) @map("is_verified")
  isPrimary  Boolean   @default(false) @map("is_primary")
  createdAt  DateTime  @default(now()) @map("created_at")
  verifiedAt DateTime? @map("verified_at")

  user User @relation("UserEmails", fields: [userId], references: [id])

  /// Backref for the optional primaryEmail relation on User (1:1)
  primaryOf User? @relation("PrimaryEmail")

  @@unique([userId, id]) // supports composite FK from User(id, primaryEmailId) -> (userId, id)
  @@index([userId, isPrimary])
  @@map("user_emails")
}

// [1.3] User roles and capabilities
enum UserRoleScope {
  global
  tenant
  service
}

model UserRole {
  id          Int           @id @map("id") // SMALLINT â†’ Int
  key         String        @unique
  label       String
  level       Int
  scope       UserRoleScope
  description String
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")

  // Relations
  roleCapabilities UserRoleCapability[]
  roleAssignments  UserRoleAssignment[] // opposite relation for UserRoleAssignment

  @@map("user_roles")
}

model UserCapability {
  key         String @id
  description String

  // Relations
  roleCapabilities UserRoleCapability[]

  @@map("user_capabilities")
}

enum CapabilityValue {
  allow
  deny
  consent
  compliance
  scoped
  anonymized
}

model UserRoleCapability {
  roleId        Int
  capabilityKey String
  value         CapabilityValue @default(deny)

  // Relations
  role       UserRole       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  capability UserCapability @relation(fields: [capabilityKey], references: [key], onDelete: Cascade)

  @@id([roleId, capabilityKey])
  @@map("user_role_capabilities")
}

model UserRoleAssignment {
  id     String @id @default(cuid())
  userId String
  roleId Int

  user User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role UserRole @relation(fields: [roleId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@unique([userId, roleId])
  @@index([roleId])
  @@map("user_role_assignments")
}

// [1.4] Session model
model Session {
  id           String  @id @default(cuid()) @map("id")
  userId       String  @map("user_id")
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String  @unique @map("token")
  ipHash       String? @map("ip_hash")
  userAgent    String? @map("user_agent")
  roles        Json?   @map("roles")
  capabilities Json?   @map("capabilities")

  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

// [1.5] Tokens for invites, email verification 
model VerificationToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToVerificationTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  purpose   String   @map("purpose") // 'email-verify'
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("verification_tokens")
}

// [1.6] Tokens for password resets
model PasswordResetToken {
  id        String   @id @default(cuid()) @map("id")
  userId    String   @map("user_id")
  user      User     @relation(name: "UserToPasswordResetTokens", fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique @map("token")
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}
